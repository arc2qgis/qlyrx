# -*- coding: utf-8 -*-
"""
/***************************************************************************
 qlyrxDialog
                                 A QGIS plugin
 Apply Arcgis Pro .lyrx style
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-04-09
        git sha              : $Format:%H$
        copyright            : (C) 2019 by arc2qgis
        email                : dror.bogin@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from qgis.core import (QgsProject, QgsWkbTypes, QgsColorRampShader, QgsPresetSchemeColorRamp, QgsRasterShader, QgsRasterBandStats, 
                        QgsSymbol, QgsSingleSymbolRenderer,QgsSingleBandPseudoColorRenderer, QgsSimpleLineSymbolLayer, 
                        QgsLinePatternFillSymbolLayer, QgsFontMarkerSymbolLayer, QgsSettings,
                        QgsPointPatternFillSymbolLayer, QgsMarkerLineSymbolLayer, QgsMarkerSymbol, 
                        QgsSimpleMarkerSymbolLayerBase, QgsSimpleMarkerSymbolLayer, QgsSVGFillSymbolLayer, 
                        QgsPalLayerSettings, QgsTextFormat, QgsVectorLayerSimpleLabeling, QgsRendererCategory, QgsCategorizedSymbolRenderer)
from PyQt5.QtWidgets import QAction, QFileDialog, QHBoxLayout, QLabel, QComboBox, QDialog
from collections import OrderedDict
from PyQt5.QtGui import QIcon, QColor, QFont


class qlyrxStyler():
    def __init__(self, parent=None):
        
        self.capStyles = {"Round" : 32, "Square" : 1, "Butt": 0}
        self.joinStyles = {"Miter": 0, "Bevel" : 64, "Round": 128}
        self.point2mm =  0.352778
        self.paths_to_shapes_array = {
            "Cross2" : {"paths" : [
                [[-0.5,0.5],[0.5,-0.5]],
                [[-0.5,-0.5],[0.5,0.5]]
            ]},
            "Line" : {"paths" : [
                [[3,0],[-3,0]]
            ]
            }
        }

        self.circle_rings = {
                            "curveRings" : [
                            [[1.2246467991473532e-16,2],
                                {
                                "a" : [[1.2246467991473532e-16,2],
                                    [0,0],[0,1]]
                                }]
                            ]
                        }

    def apply_lyrx_symbols(self, dlg, layer, lyrx_data, geometry_general_type_str):
        simple_symbol = False
        raster_symbol = False
        label_symbol = False
        layerDef = lyrx_data['layerDefinitions']
        renderer = ''
        renderers = []
        renderers_symb_type = []
        dataset_names = []
        raster_data = ''
        label_symb_array = []
        label_expessions = []
        labels = ''

        for p in layerDef :
            #print(p)
            if 'type' in p:
               if p['type'] == 'CIMRasterLayer':
                   raster_symbol = True
                   raster_data = p
               else:
                    raster_symbol = False
            ## Check for renderers
            temp_renderer = p['renderer'] if 'renderer' in p else ''
            renderers.append(temp_renderer)
            temp_label = p['labelClasses'] if 'labelClasses' in p else ''
            label_symb_array.append(temp_label)
            try:
                label_expr = self.getLabelField(temp_label[0]) if len(temp_label) else ''
                #print(label_expr)
                if label_expr:
                    label_symbol = True
                    label_expessions.append(label_expr)
                else:
                    label_expessions.append('')
                ## Get lyrx shape type and original names
                if not temp_renderer == '' and not raster_symbol:
                    if 'symbol' in temp_renderer:
                        rend_type = temp_renderer['symbol']['type']
                    elif 'defaultSymbol' in temp_renderer:
                        rend_type = temp_renderer['defaultSymbol']['symbol']['type']
                    elif 'groups' in temp_renderer:
                        group0 = temp_renderer['groups'][0]
                        if 'classes' in group0:
                            symbol0 = group0['classes'][0]
                            rend_type = symbol0['symbol']['symbol']['type']

                    #rend_type = temp_renderer['symbol']['type'] if 'symbol' in temp_renderer else  temp_renderer['defaultSymbol']['symbol']['type']
                    renderers_symb_type.append(rend_type.lower())
                    dataset = p['featureTable']['dataConnection']['dataset']
                    dataset_names.append(dataset)
            except Exception as e:
                print(e)
        print("there are " + str(len(label_symb_array)) + " label def")

                
        # Find a renderer with the active layer field attribute
        rend_to_check = []
        x = 0   
        for r in renderers_symb_type:
            if geometry_general_type_str in r:            
                rend_to_check.append(x)
            x = x + 1

        rend_idx = -1
        self.used_fields = []
        #print(rend_to_check)
        ## Check in the active layers for matching classification fields  
        for z in rend_to_check:
            for f in renderers[z]['fields']:
                if f not in self.used_fields:
                    self.used_fields.append(f)
            #print(renderers[z]['fields'][0])
            #print(layer.fields())
            ## Check for matching column names
            field_exist = layer.fields().indexFromName(renderers[z]['fields'][0])
            if field_exist > -1:
                rend_idx = z
        
        #for u in range(0,len(self.used_fields)):
        #    self.add_field_layout(layer,self.used_fields[u],u)
        
        # Check simple symbol        
        if rend_idx < 0 and not raster_symbol:
            active_name = layer.sourceName()
            rend_idx = dataset_names.index(active_name) if layer.sourceName() in dataset_names else 0
            if renderers[0]['type'] != "CIMSimpleRenderer":
                simple_symbol = False
            else:    
                simple_symbol = True

        if rend_idx > -1 and not simple_symbol:
            ## Create data arrays for symbols, labels, symbolLayers, halo options
            categories = []
            allSymbolLayers = {}
            class_field = renderers[rend_idx]['fields'][0] if len(renderers[rend_idx]['fields']) > 0 else 'CODE'
            class_field2 = renderers[rend_idx]['fields'][1] if len(renderers[rend_idx]['fields']) > 1 else ''
            class_field3 = renderers[rend_idx]['fields'][2] if len(renderers[rend_idx]['fields']) > 2 else ''
            #print(class_field)
            classes = renderers[rend_idx]["groups"][0]["classes"]
            symbols_labels = []
            symbol_layers = []
            symbol_values = []    
            halo_symbols = []
            multi_cat = []
            for c in classes :    
                symbol_layers.append(self.getSymbolLayers(c))
                halo_symbols.append(self.getSymbolHalo(c))
                symbols_labels.append(c['label'])
                symbol_values.append(c['values'][0]['fieldValues'])
                if len(c['values']) > 1:
                    vf_idx = 0
                    multi_array = []
                    for vf in c['values']:
                        if vf_idx > 0:
                           multi_array.append(vf['fieldValues'])             
                        vf_idx = vf_idx + 1    
                    multi_cat.append(multi_array)
                else:
                    multi_cat.append('')

            ## Convert the symbolLayers definition of each CIMUniqueValueClass to qgis symbol and create a category
            idx = 0
            for sl in symbol_layers:
                #print(sl)
                #print ("val :" + str(symbol_values[idx][0]))
                allSymbolLayers = {}                                    
                ## Create definition array - add order and more    
                symbol_def = self.checkSymbolType(sl)
                layer_num = symbol_def['layer_count']            
                #print("Symology count is " + str(layer_num))            
                ret_arr = self.parseSolidFill(symbol_def, layer)            
                ret = ret_arr[0]
                #print("solid fill idx " + str(ret_arr[1])) 
                allSymbolLayers[ret_arr[1]] = ret                        
                noSolid = False
                firstDash = False
                if ret_arr[1] < 0:
                    noSolid = True                   

                svg_file_appendix = str(symbol_values[idx][0]).replace(" ","_")
                picture_ret = self.parsePictureFill(symbol_def, svg_file_appendix)
                if not picture_ret[0] == '':
                    print("pic fill try")
                    allSymbolLayers[picture_ret[1]] = picture_ret[0]
                    ret.appendSymbolLayer(picture_ret[0])
                ## Create hatch fill 
                lines_ret = self.parseLineFill(symbol_def, layer)            
                #print(len(line_ret))
                if not lines_ret == '':
                    line_ret = lines_ret[0]
                    #print("hatch number is " + str(len(line_ret)))
                    for line in line_ret:
                        try:
                            ret.appendSymbolLayer(line)
                        except:
                            print(line.__class__.__name__)
                    for line_sym in lines_ret[1]:
                        allSymbolLayers[line_sym] = lines_ret[1][line_sym]                    

                ## Create line strokes symbols
                if 'template_stroke_num' in symbol_def and not ret == '':                
                    ret_val = self.parseStroke(symbol_def, ret, layer)  
                    ret = ret_val[0]
                    stroke_symbols = ret_val[1] 
                    for str_s in stroke_symbols:
                        #print(str_s)
                        allSymbolLayers[str_s] = stroke_symbols[str_s]                                    
                    firstDash = ret_val[2]
                        
                vector_layers = self.parseVectorSymbolLine(symbol_def, False, layer)
                #print(vector_layers)
                if not vector_layers == '':
                    vl_idx = vector_layers
                    for vl in vector_layers:
                        v_symb = vl[0]
                        v_ord = vl[1]
                        allSymbolLayers[v_ord] = v_symb
                        ret.appendSymbolLayer(v_symb)
                        #print("After vector")
                    
                    #allSymbolLayers[vl_idx] = vector_layers[0]
                    #ret.appendSymbolLayer(vector_layers[0])
                    

                ## Create character fills
                layers = []
                max_size = 0            
                for charSl in sl:            
                    if 'characterIndex' in charSl and charSl['type'] == 'CIMCharacterMarker':
                        #print(charSl["enable"])
                        if charSl["enable"]:
                            ret_sym = self.parseCharacterFill(charSl, max_size, layer)
                            #print(ret_sym)
                            symbol = ret_sym[0]                        
                            if not symbol == '':
                                #print("char symb desc " + str(charSl['sl_idx']))                            
                                layers.append(symbol)                            
                                allSymbolLayers[ret_sym[1]] = symbol
                                if geometry_general_type_str == 'point':          
                                    max_size = max(symbol.size(), max_size)            
                
                if not halo_symbols[idx] == '':
                    layers = self.tweakHaloSymbol(layers, halo_symbols[idx], layer)
                    allSymbolLayers[len(allSymbolLayers) + 1] = layers[len(layers) - 1].clone()            
                
                ## Add the font fill 
                x = 0                                        
                for rl in layers:                
                    ret.appendSymbolLayer(rl)                
                    x = x + 1
                
                ## Delete default base layer if font marker filled or symbol mismatch
                #print("is Halo " + str(halo_symbols[idx] == ''))            
                #print("ret count is " + str(ret.symbolLayerCount()))
                
                if ((len(layers) > 0 and noSolid ) or (layer_num < ret.symbolLayerCount()) or firstDash ):                                
                    print("delete first symbol layer")
                    # add user interaction
                    ret.deleteSymbolLayer(0)
                    if -1 in allSymbolLayers:
                        print("fix demo first layer")
                        # add user interaction        
                        del(allSymbolLayers[-1])
                
                #print("symbol layers in object " + str(len(allSymbolLayers)))
                #print("ret symbols " + str(ret.symbolLayerCount()))
                
                ## Create ordered object from allSymbolLayers
                ordered_obj = OrderedDict(sorted(allSymbolLayers.items(), key=lambda t: t[0]))
                #print("len " + str(len(allSymbolLayers)))
                total_len = ret.symbolLayerCount()
                total_sym_len = len(ordered_obj)
                if -1 in ordered_obj  and not total_len in ordered_obj:
                    #print("!!!!!!!!!!!!Fix by total length")
                    # TODO: add user interaction
                    ordered_obj[total_len] = ordered_obj[-1].clone()
                    del(ordered_obj[-1])
                                    
                ## Create the new symbol from reveresed ordered_obj
                new_symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                baseLayer = False
                try:
                    if total_sym_len > 1:
                        for ord_sym_idx in reversed(ordered_obj):
                            #print("in reorder loop " + str(ord_sym_idx))
                            newSymbolLayer  = ordered_obj[ord_sym_idx].clone()
                            locked = ''
                            if not 'SymbolLayer' in newSymbolLayer.__class__.__name__:
                                #print("try symbolLayer")
                                newSymbolLayer = ordered_obj[ord_sym_idx].symbolLayer(0).clone()
                                locked = ordered_obj[ord_sym_idx].symbolLayer(0).isLocked()                                
                            else:
                                locked = ordered_obj[ord_sym_idx].isLocked()
                            #print("locked " + str(locked))    
                            newSymbolLayer.setLocked(locked)    
                            if not baseLayer:                                                        
                                if "SymbolLayer" in newSymbolLayer.__class__.__name__:                                
                                    new_symbol.changeSymbolLayer(0, newSymbolLayer)
                                baseLayer = True
                            else:                                                        
                                if "SymbolLayer" in newSymbolLayer.__class__.__name__:                                
                                    new_symbol.appendSymbolLayer(newSymbolLayer)                                
                    else:
                        #print("one layered symbol")
                        new_symbol = ret
                except:
                    print("order fail")
                    # add user interaction
                        
                #print("new symbol count"  + str(new_symbol.symbolLayerCount()))

                ## Create new category                            
                symbol_val_prep = symbol_values[idx][0] + ", " + symbol_values[idx][1] if len(symbol_values[idx]) > 1 else symbol_values[idx][0]            
                category = QgsRendererCategory(symbol_val_prep, new_symbol, symbols_labels[idx])            
                categories.append(category)
                
                #if len(symbol_values[idx] > 2):
                if not multi_cat[idx] == '':
                    for extra_label in multi_cat[idx]:
                        symbol_val_prep1 = extra_label[0] + ", " + extra_label[1] if len(extra_label) > 1 else extra_label[0]            
                        category = QgsRendererCategory(symbol_val_prep1, new_symbol.clone(), symbols_labels[idx])            
                        categories.append(category)
                       
                idx = idx + 1
                
            ## Create renderer                        
            concat_str =  ", " + "', ', " + class_field2 + ")" if not class_field2 == "" else ")"
            renderer = QgsCategorizedSymbolRenderer("concat(" + class_field + concat_str, categories)
            #print(categories)
            
        elif not raster_symbol and renderers[rend_idx]['type'] == 'CIMSimpleRenderer' and simple_symbol:
            single_symbology = self.parseSimpleRenderer(renderers[rend_idx], layer)
            #print(single_symbology)
            if not single_symbology == '':
                #print('simple renderer')
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                try:
                    symbol.changeSymbolLayer(0, single_symbology)
                except:
                    symbol = single_symbology
                    
                renderer = QgsSingleSymbolRenderer(symbol)
        elif raster_symbol:
            self.mb.pushWarning('Warning',"Raster symbology is still experimental")
            self.parseRasterData(raster_data, layer)
            #layer.triggerRepaint()
            #self.iface.legendInterface().refreshLayerSymbology(layer)
        else:
            self.mb.pushCritical('',"No matching lyrx symbology fields found for the active layer")
            # add user interaction
        
        if label_symbol: 
            #print(label_symbol)
            #print(label_expessions)
            #print(label_symb_array)
            labels = self.parseLabels(label_symb_array, label_expessions, layer, rend_idx)
            print("label by layer num " + str(rend_idx) + " in lyrx")

        # assign the created renderer to the layer
        if not renderer == '' :
            #print("re-render")
            layer.setRenderer(renderer)
            layer.triggerRepaint()
        
        if not labels == '':
            layer.setLabeling(labels)
            if not dlg.parseLables.isChecked():
                layer.setLabelsEnabled(False) 
            layer.triggerRepaint()
            print("after labeling")


    def initial_lyrx_parse(self,lyrx_data,layer):
        "perform initial parsing of lyrx values and create ui elements for the required fields"
        simple_symbol = False
        raster_symbol = False
        label_symbol = False
        layerDef = lyrx_data['layerDefinitions']
        renderer = ''
        renderers = []
        renderers_symb_type = []
        dataset_names = []
        raster_data = ''
        label_symb_array = []
        label_expessions = []
        labels = ''
        for p in layerDef :
            if 'type' in p:
               if p['type'] == 'CIMRasterLayer':
                   raster_symbol = True
                   raster_data = p
            ## Check for renderers
            temp_renderer = p['renderer'] if 'renderer' in p else ''
            renderers.append(temp_renderer)
            temp_label = p['labelClasses'] if 'labelClasses' in p else ''
            label_symb_array.append(temp_label)
            try:
                label_expr = self.getLabelField(temp_label[0]) if len(temp_label) else ''
                #print(label_expr)
                if label_expr:
                    label_symbol = True
                    label_expessions.append(label_expr)
                else:
                    label_expessions.append('')
                ## Get lyrx shape type and original names
                if not temp_renderer == '' and not raster_symbol:
                    rend_type = temp_renderer['symbol']['type'] if 'symbol' in temp_renderer else  temp_renderer['defaultSymbol']['symbol']['type']
                    renderers_symb_type.append(rend_type.lower())
                    dataset = p['featureTable']['dataConnection']['dataset']
                    dataset_names.append(dataset)
            except Exception as e:
                print(e)
        print("there are " + str(len(label_symb_array)) + " label def")
        # Find a renderer with the active layer field attribute
        rend_to_check = []
        x = 0    
        for r in renderers_symb_type:
            print(r)
            #if geometry_general_type_str in r:            
            rend_to_check.append(x)
            x = x + 1

        rend_idx = -1
        self.used_fields = []
        ## Check in the active layers for matching classification fields  
        for z in rend_to_check:
            for f in renderers[z]['fields']:
                if f not in self.used_fields:
                    self.used_fields.append(f)
            field_exist = layer.fields().indexFromName(renderers[z]['fields'][0])
            if field_exist > -1:
                rend_idx = z
        #for u in range(0,len(self.used_fields)):
            #self.add_field_layout(dlg,layer,self.used_fields[u],u)

    def clear_field_layout(self, dlg):
        fields_layout = dlg.field_selection
        for n in range(0,fields_layout.count()):
            fields_layout.removeItem(fields_layout.itemAt(n))


    def add_field_layout(self,dlg,layer,field_name,index):
        self.clear_field_layout(dlg)
        fields_layout = dlg.field_selection
        span = QHBoxLayout()
        #span.setObjectName("span_{}+{}".format(str(field_name)+str(index+1)))
        label = QLabel()
        #label.setObjectName("label_{}+{}".format(str(field_name)+str(index+1)))
        label.setText("{}  :  ".format(str(field_name)))
        field_select = QComboBox()
        #field_select.setObjectName("fieldSelect_{}+{}".format(str(field_name)+str(index+1)))
        field_select.addItems(layer.fields().names())
        span.addWidget(label)
        span.addWidget(field_select)
        fields_layout.insertLayout(index,span)
        #return
        
    def getLabelField(self, labelObj):
        label_exp = ''
        if 'expression' in labelObj:
            label_exp = labelObj['expression']
        return label_exp
    
    def parseLabels(self, labelSymbArr, labelExpArr, layer, layerId = 0):
        #print(layerId)
        #print(labelExpArr)
        #print(labelSymbArr)
        label = ''
        labelExp = labelExpArr[layerId]
        ## Parse label expression - by default - one label with brackets (VB syntax)
        ##TODO: Generelize
        if "[" in labelExp:
            labelExp = labelExp[1:-1]
            
        labelParse = labelSymbArr[layerId][0]
        labelSymbol = labelParse['textSymbol']
        
        ## Init properties
        try:
            fontFamily = labelSymbol['symbol']['fontFamilyName'] if labelSymbol['symbol']['fontFamilyName'] else 'David'
            fontSize = labelSymbol['symbol']['height'] if labelSymbol['symbol']['height'] else 12
            color = labelSymbol['symbol']['symbol']['symbolLayers'][0]['color']
            ptColor = self.colorToRgbArray(color['values'], color['type'])
            fontWeight = labelSymbol['symbol']['fontStyleName'] if labelSymbol['symbol']['fontStyleName'] else 'Regular'
            minimumScale = labelParse['minimumScale'] if 'minimumScale' in labelParse else ''            
        except Exception as e:
            print(e)
        
        # Create label settings    
        label_settings  = QgsPalLayerSettings()
        # Create font settings    
        text_format = QgsTextFormat()
        text_format.setFont(QFont(fontFamily, fontSize))
        text_format.setSize(fontSize)
        text_format.setColor(ptColor)
        text_format.setNamedStyle(fontWeight)
        #buffer_settings = QgsTextBufferSettings()
        #buffer_settings.setEnabled(True)
        #buffer_settings.setSize(0.30)
        #buffer_settings.setColor(QColor("black"))
        #text_format.setBuffer(buffer_settings)
        
        label_settings.setFormat(text_format)
        label_settings.fieldName = labelExp
        
        ## Default label placement 
        ## TODO: create conversion object to all placement properties
        label_settings.placement = 1
        label_settings.centroidInside = 1
        label_settings.centroidWhole = 1
        ## Scale visibility
        try:
            label_settings.scaleVisibility = True if not minimumScale == '' else False
            label_settings.minimumScale = minimumScale if not minimumScale == '' else 0
        except Exception as e:
            print(e)    
        ## Label visibility
        label_settings.enabled = True
        label_settings = QgsVectorLayerSimpleLabeling(label_settings)
        layer.setLabelsEnabled(True)        
        ## 
        #layer.setLabeling(label_settings)        
        
        return label_settings

